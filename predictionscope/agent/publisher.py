"""
PredictionScope Content Publisher
Manages the review queue via GitHub PRs and deployment pipeline.
"""

import os
import json
import logging
import subprocess
from datetime import datetime
from pathlib import Path

logger = logging.getLogger("predictionscope")


class ContentPublisher:
    """Publishes content through GitHub PR workflow."""

    def __init__(self, config: dict):
        self.config = config
        self.repo_path = os.environ.get("REPO_PATH", ".")
        self.review_mode = config.get("review", {}).get("mode", "pr")

    def create_review_pr(self, article: dict) -> str:
        """
        Create a GitHub PR with the article for human review.

        Flow:
        1. Create a new branch from main
        2. Write the article markdown to the content directory
        3. Commit and push
        4. Open a PR with article metadata in the description
        5. Return the PR URL
        """
        bucket = article["bucket"]
        slug = article["slug"]
        branch_name = f"content/{bucket}/{slug}-{datetime.now().strftime('%Y%m%d')}"

        try:
            # Create branch
            self._run_git("checkout", "main")
            self._run_git("pull", "origin", "main")
            self._run_git("checkout", "-b", branch_name)

            # Write content file
            content_path = f"content/{bucket}/{slug}.md"
            os.makedirs(os.path.dirname(content_path), exist_ok=True)
            with open(content_path, "w") as f:
                f.write(article["content"])

            # Commit
            self._run_git("add", content_path)
            commit_msg = (
                f"[agent] Add {bucket} article: {article['title']}\n\n"
                f"Bucket: {bucket}\n"
                f"Target keywords: {', '.join(article.get('target_keywords', []))}\n"
                f"Word count: {article.get('word_count', 'unknown')}\n"
                f"Generated: {article.get('generated_at', 'unknown')}"
            )
            self._run_git("commit", "-m", commit_msg)

            # Push
            self._run_git("push", "origin", branch_name)

            # Create PR
            pr_url = self._create_github_pr(
                branch=branch_name,
                title=f"[{bucket.upper()}] {article['title']}",
                body=self._build_pr_description(article),
            )

            # Return to main
            self._run_git("checkout", "main")

            return pr_url

        except Exception as e:
            logger.error(f"Failed to create PR: {e}")
            # Cleanup
            try:
                self._run_git("checkout", "main")
                self._run_git("branch", "-D", branch_name)
            except Exception:
                pass
            raise

    def _build_pr_description(self, article: dict) -> str:
        """Build a descriptive PR body for human reviewers."""
        return f"""## ðŸ¤– AI-Generated Content â€” Review Required

**Article:** {article['title']}
**Bucket:** `{article['bucket']}` ({article['bucket']})
**Slug:** `{article['slug']}`
**Target Keywords:** {', '.join(article.get('target_keywords', []))}
**Word Count:** {article.get('word_count', 'unknown')}
**Meta Description:** {article.get('meta_description', '')}

### Review Checklist
- [ ] Factual accuracy â€” are all market data points correct?
- [ ] Brand voice â€” does this sound like PredictionScope?
- [ ] Internal links â€” are they relevant and working?
- [ ] SEO â€” title, meta description, keyword usage look good?
- [ ] Affiliate links â€” correct and properly disclosed? (if applicable)
- [ ] No fabricated data or misleading claims

### Reviewer Actions
- âœ… **Approve & merge** â†’ triggers build + deploy
- âœï¸ **Edit** â†’ make changes, then approve
- âŒ **Reject** â†’ close PR with comment explaining why (agent learns from this)
- ðŸ”„ **Request regen** â†’ comment with notes, label `regen-requested`

---
*Generated by PredictionScope Agent at {article.get('generated_at', 'unknown')}*
"""

    def _run_git(self, *args):
        """Run a git command."""
        cmd = ["git", "-C", self.repo_path] + list(args)
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode != 0:
            raise RuntimeError(f"Git command failed: {' '.join(cmd)}\n{result.stderr}")
        return result.stdout.strip()

    def _create_github_pr(self, branch: str, title: str, body: str) -> str:
        """Create a GitHub PR using the gh CLI."""
        try:
            result = subprocess.run(
                [
                    "gh",
                    "pr",
                    "create",
                    "--base",
                    "main",
                    "--head",
                    branch,
                    "--title",
                    title,
                    "--body",
                    body,
                    "--label",
                    "agent-generated",
                ],
                capture_output=True,
                text=True,
                cwd=self.repo_path,
            )
            if result.returncode == 0:
                return result.stdout.strip()  # Returns the PR URL
            else:
                logger.error(f"gh pr create failed: {result.stderr}")
                return f"PR creation failed: {result.stderr}"
        except FileNotFoundError:
            logger.warning("gh CLI not installed, saving PR metadata locally")
            pr_log = {
                "branch": branch,
                "title": title,
                "body": body,
                "created_at": datetime.now().isoformat(),
            }
            log_path = f"logs/pending-prs/{branch.replace('/', '-')}.json"
            os.makedirs(os.path.dirname(log_path), exist_ok=True)
            with open(log_path, "w") as f:
                json.dump(pr_log, f, indent=2)
            return f"local://{log_path}"

    def get_recent_rejections(self) -> list[dict]:
        """
        Fetch recently rejected PRs to learn from feedback.
        Returns list of {title, reason, date}.
        """
        try:
            result = subprocess.run(
                [
                    "gh",
                    "pr",
                    "list",
                    "--state",
                    "closed",
                    "--label",
                    "agent-generated",
                    "--limit",
                    "20",
                    "--json",
                    "title,body,closedAt,mergedAt",
                ],
                capture_output=True,
                text=True,
                cwd=self.repo_path,
            )
            if result.returncode == 0:
                prs = json.loads(result.stdout)
                # Rejections are closed but NOT merged
                rejections = [
                    {
                        "title": pr["title"],
                        "reason": pr.get("body", "No reason given"),
                        "date": pr.get("closedAt", ""),
                    }
                    for pr in prs
                    if not pr.get("mergedAt")
                ]
                return rejections
        except Exception as e:
            logger.warning(f"Could not fetch rejections: {e}")

        return []
